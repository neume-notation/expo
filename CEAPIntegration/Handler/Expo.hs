-- Author: Paul Rouse
-- Copyright 2017 University of Bristol
-- Licensed under BSD-3-Clause - see the LICENSE file or http://opensource.org
--
module Handler.Expo (
    getExpoR,
    getTrackR
) where

import Import          hiding (joinPath)
import Layout.Expo                   (expoLayout)
import Layout.ExpoIsStandAlone       (standAlone)
import System.FilePath               (joinPath)
import Data.Aeson                    (decode', Value(..))
import Text.Blaze.Html.Renderer.Text (renderHtml)
import Text.Hamlet                   (hamletFile)
import Text.Julius                   (juliusFile, renderJavascriptUrl)
import Data.Word8                    (_braceleft)

import Handler.MiniCEAP              (miniCEAP, similarNeumes, transcription)

-- This is for development, and should commented out in production.  It gives
-- a way of spelling "null" in locHLs.julius which distinguishes those
-- entries which are still to be done (#{dummy_null}) from those which are
-- intentionally null (null).
-- dummy_null :: Value
-- dummy_null = Null

-- The exhibition software is truly a single page application, and, once
-- loaded, complete with CSS, javascript libraries, and the compiled
-- Purescript code, it refers back to the server only for static resources
-- such as images and videos.  Data used to drive the exhibit is embedded
-- in the Html, and is collected together by this handler.  A dedicated
-- page layout is used, since specific CSS and libraries are needed, and
-- it includes the script tag referring to the compiled Purescript; this
-- is generated by `Layout.Expo.expoLayout`.
--
-- In this handler, data files are collected together, performing Route
-- substitutions in some cases, and they are combined into a widget which
-- defines a single top-level javascript object.  This widget is embedded
-- into the Html <head> to ensure that it is in scope before the Purescript
-- code is loaded by its <script> element, which is in the <body>.
--
getExpoR :: Handler Html
getExpoR = do

    urlRender <- getUrlRenderParams

    -- The talk text comes from several separate files, each corresponding
    -- to a specific property name in the combined data object.  For each
    -- one, there is a parallel timings file, which is pure JSON.

    -- English
    -- -------

    introGChtmlEn <- readDataUtf8 ["talks", "en", "intro_gc.html"]
    introGCtimeEn <- jsonTiming <$> readData ["talks", "en", "intro_gc.json"]
    introL5htmlEn <- readDataUtf8 ["talks", "en", "intro_l5.html"]
    introL5timeEn <- jsonTiming <$> readData ["talks", "en", "intro_l5.json"]

    codexB1htmlEn <- readDataUtf8 ["talks", "en", "codex_b1.html"]
    codexB1timeEn <- jsonTiming <$> readData ["talks", "en", "codex_b1.json"]
    codexCAhtmlEn <- readDataUtf8 ["talks", "en", "codex_ca.html"]
    codexCAtimeEn <- jsonTiming <$> readData ["talks", "en", "codex_ca.json"]
    codexL5htmlEn <- readDataUtf8 ["talks", "en", "codex_l5.html"]
    codexL5timeEn <- jsonTiming <$> readData ["talks", "en", "codex_l5.json"]
    codexLOhtmlEn <- readDataUtf8 ["talks", "en", "codex_lo.html"]
    codexLOtimeEn <- jsonTiming <$> readData ["talks", "en", "codex_lo.json"]

    useofmsB1htmlEn <- readDataUtf8 ["talks", "en", "useofms_b1.html"]
    useofmsB1timeEn <- jsonTiming <$> readData ["talks", "en", "useofms_b1.json"]
    useofmsCAhtmlEn <- readDataUtf8 ["talks", "en", "useofms_ca.html"]
    useofmsCAtimeEn <- jsonTiming <$> readData ["talks", "en", "useofms_ca.json"]
    useofmsL5htmlEn <- readDataUtf8 ["talks", "en", "useofms_l5.html"]
    useofmsL5timeEn <- jsonTiming <$> readData ["talks", "en", "useofms_l5.json"]
    useofmsLOhtmlEn <- readDataUtf8 ["talks", "en", "useofms_lo.html"]
    useofmsLOtimeEn <- jsonTiming <$> readData ["talks", "en", "useofms_lo.json"]

    -- "music" is a special case, as it is a hamlet file, not pure html
    let musicUrlEn  = $(hamletFile "templates/expo/data/talks/en/music.hamlet")
        musicHtmlEn = renderHtml $ musicUrlEn urlRender
    musicTimeEn   <- jsonTiming <$> readData ["talks", "en", "music.json"]

    cadenceB1htmlEn <- readDataUtf8 ["talks", "en", "cadence_b1.html"]
    cadenceB1timeEn <- jsonTiming <$> readData ["talks", "en", "cadence_b1.json"]
    cadenceCAhtmlEn <- readDataUtf8 ["talks", "en", "cadence_ca.html"]
    cadenceCAtimeEn <- jsonTiming <$> readData ["talks", "en", "cadence_ca.json"]
    cadenceL5htmlEn <- readDataUtf8 ["talks", "en", "cadence_l5.html"]
    cadenceL5timeEn <- jsonTiming <$> readData ["talks", "en", "cadence_l5.json"]
    cadenceLOhtmlEn <- readDataUtf8 ["talks", "en", "cadence_lo.html"]
    cadenceLOtimeEn <- jsonTiming <$> readData ["talks", "en", "cadence_lo.json"]

    textbitsB1htmlEn <- readDataUtf8 ["talks", "en", "textbits_b1.html"]
    textbitsB1timeEn <- jsonTiming <$> readData ["talks", "en", "textbits_b1.json"]
    textbitsCAhtmlEn <- readDataUtf8 ["talks", "en", "textbits_ca.html"]
    textbitsCAtimeEn <- jsonTiming <$> readData ["talks", "en", "textbits_ca.json"]
    textbitsL5htmlEn <- readDataUtf8 ["talks", "en", "textbits_l5.html"]
    textbitsL5timeEn <- jsonTiming <$> readData ["talks", "en", "textbits_l5.json"]
    textbitsLOhtmlEn <- readDataUtf8 ["talks", "en", "textbits_lo.html"]
    textbitsLOtimeEn <- jsonTiming <$> readData ["talks", "en", "textbits_lo.json"]

    textmoreB1htmlEn <- readDataUtf8 ["talks", "en", "textmore_b1.html"]
    textmoreB1timeEn <- jsonTiming <$> readData ["talks", "en", "textmore_b1.json"]
    textmoreCAhtmlEn <- readDataUtf8 ["talks", "en", "textmore_ca.html"]
    textmoreCAtimeEn <- jsonTiming <$> readData ["talks", "en", "textmore_ca.json"]
    textmoreL5htmlEn <- readDataUtf8 ["talks", "en", "textmore_l5.html"]
    textmoreL5timeEn <- jsonTiming <$> readData ["talks", "en", "textmore_l5.json"]
    textmoreLOhtmlEn <- readDataUtf8 ["talks", "en", "textmore_lo.html"]
    textmoreLOtimeEn <- jsonTiming <$> readData ["talks", "en", "textmore_lo.json"]

    -- Spanish
    -- -------

    introGChtmlEs <- readDataUtf8 ["talks", "es", "intro_gc.html"]
    introGCtimeEs <- jsonTiming <$> readData ["talks", "es", "intro_gc.json"]
    introL5htmlEs <- readDataUtf8 ["talks", "es", "intro_l5.html"]
    introL5timeEs <- jsonTiming <$> readData ["talks", "es", "intro_l5.json"]

    codexB1htmlEs <- readDataUtf8 ["talks", "es", "codex_b1.html"]
    codexB1timeEs <- jsonTiming <$> readData ["talks", "es", "codex_b1.json"]
    codexCAhtmlEs <- readDataUtf8 ["talks", "es", "codex_ca.html"]
    codexCAtimeEs <- jsonTiming <$> readData ["talks", "es", "codex_ca.json"]
    codexL5htmlEs <- readDataUtf8 ["talks", "es", "codex_l5.html"]
    codexL5timeEs <- jsonTiming <$> readData ["talks", "es", "codex_l5.json"]
    codexLOhtmlEs <- readDataUtf8 ["talks", "es", "codex_lo.html"]
    codexLOtimeEs <- jsonTiming <$> readData ["talks", "es", "codex_lo.json"]

    useofmsB1htmlEs <- readDataUtf8 ["talks", "es", "useofms_b1.html"]
    useofmsB1timeEs <- jsonTiming <$> readData ["talks", "es", "useofms_b1.json"]
    useofmsCAhtmlEs <- readDataUtf8 ["talks", "es", "useofms_ca.html"]
    useofmsCAtimeEs <- jsonTiming <$> readData ["talks", "es", "useofms_ca.json"]
    useofmsL5htmlEs <- readDataUtf8 ["talks", "es", "useofms_l5.html"]
    useofmsL5timeEs <- jsonTiming <$> readData ["talks", "es", "useofms_l5.json"]
    useofmsLOhtmlEs <- readDataUtf8 ["talks", "es", "useofms_lo.html"]
    useofmsLOtimeEs <- jsonTiming <$> readData ["talks", "es", "useofms_lo.json"]

    -- "music" is a special case, as it is a hamlet file, not pure html
    let musicUrlEs  = $(hamletFile "templates/expo/data/talks/es/music.hamlet")
        musicHtmlEs = renderHtml $ musicUrlEs urlRender
    musicTimeEs   <- jsonTiming <$> readData ["talks", "es", "music.json"]

    cadenceB1htmlEs <- readDataUtf8 ["talks", "es", "cadence_b1.html"]
    cadenceB1timeEs <- jsonTiming <$> readData ["talks", "es", "cadence_b1.json"]
    cadenceCAhtmlEs <- readDataUtf8 ["talks", "es", "cadence_ca.html"]
    cadenceCAtimeEs <- jsonTiming <$> readData ["talks", "es", "cadence_ca.json"]
    cadenceL5htmlEs <- readDataUtf8 ["talks", "es", "cadence_l5.html"]
    cadenceL5timeEs <- jsonTiming <$> readData ["talks", "es", "cadence_l5.json"]
    cadenceLOhtmlEs <- readDataUtf8 ["talks", "es", "cadence_lo.html"]
    cadenceLOtimeEs <- jsonTiming <$> readData ["talks", "es", "cadence_lo.json"]

    textbitsB1htmlEs <- readDataUtf8 ["talks", "es", "textbits_b1.html"]
    textbitsB1timeEs <- jsonTiming <$> readData ["talks", "es", "textbits_b1.json"]
    textbitsCAhtmlEs <- readDataUtf8 ["talks", "es", "textbits_ca.html"]
    textbitsCAtimeEs <- jsonTiming <$> readData ["talks", "es", "textbits_ca.json"]
    textbitsL5htmlEs <- readDataUtf8 ["talks", "es", "textbits_l5.html"]
    textbitsL5timeEs <- jsonTiming <$> readData ["talks", "es", "textbits_l5.json"]
    textbitsLOhtmlEs <- readDataUtf8 ["talks", "es", "textbits_lo.html"]
    textbitsLOtimeEs <- jsonTiming <$> readData ["talks", "es", "textbits_lo.json"]

    textmoreB1htmlEs <- readDataUtf8 ["talks", "es", "textmore_b1.html"]
    textmoreB1timeEs <- jsonTiming <$> readData ["talks", "es", "textmore_b1.json"]
    textmoreCAhtmlEs <- readDataUtf8 ["talks", "es", "textmore_ca.html"]
    textmoreCAtimeEs <- jsonTiming <$> readData ["talks", "es", "textmore_ca.json"]
    textmoreL5htmlEs <- readDataUtf8 ["talks", "es", "textmore_l5.html"]
    textmoreL5timeEs <- jsonTiming <$> readData ["talks", "es", "textmore_l5.json"]
    textmoreLOhtmlEs <- readDataUtf8 ["talks", "es", "textmore_lo.html"]
    textmoreLOtimeEs <- jsonTiming <$> readData ["talks", "es", "textmore_lo.json"]

    -- Portuguese
    -- ----------

    introGChtmlPt <- readDataUtf8 ["talks", "pt", "intro_gc.html"]
    introGCtimePt <- jsonTiming <$> readData ["talks", "pt", "intro_gc.json"]
    introL5htmlPt <- readDataUtf8 ["talks", "pt", "intro_l5.html"]
    introL5timePt <- jsonTiming <$> readData ["talks", "pt", "intro_l5.json"]

    codexB1htmlPt <- readDataUtf8 ["talks", "pt", "codex_b1.html"]
    codexB1timePt <- jsonTiming <$> readData ["talks", "pt", "codex_b1.json"]
    codexCAhtmlPt <- readDataUtf8 ["talks", "pt", "codex_ca.html"]
    codexCAtimePt <- jsonTiming <$> readData ["talks", "pt", "codex_ca.json"]
    codexL5htmlPt <- readDataUtf8 ["talks", "pt", "codex_l5.html"]
    codexL5timePt <- jsonTiming <$> readData ["talks", "pt", "codex_l5.json"]
    codexLOhtmlPt <- readDataUtf8 ["talks", "pt", "codex_lo.html"]
    codexLOtimePt <- jsonTiming <$> readData ["talks", "pt", "codex_lo.json"]

    useofmsB1htmlPt <- readDataUtf8 ["talks", "pt", "useofms_b1.html"]
    useofmsB1timePt <- jsonTiming <$> readData ["talks", "pt", "useofms_b1.json"]
    useofmsCAhtmlPt <- readDataUtf8 ["talks", "pt", "useofms_ca.html"]
    useofmsCAtimePt <- jsonTiming <$> readData ["talks", "pt", "useofms_ca.json"]
    useofmsL5htmlPt <- readDataUtf8 ["talks", "pt", "useofms_l5.html"]
    useofmsL5timePt <- jsonTiming <$> readData ["talks", "pt", "useofms_l5.json"]
    useofmsLOhtmlPt <- readDataUtf8 ["talks", "pt", "useofms_lo.html"]
    useofmsLOtimePt <- jsonTiming <$> readData ["talks", "pt", "useofms_lo.json"]

    -- "music" is a special case, as it is a hamlet file, not pure html
    let musicUrlPt  = $(hamletFile "templates/expo/data/talks/pt/music.hamlet")
        musicHtmlPt = renderHtml $ musicUrlPt urlRender
    musicTimePt   <- jsonTiming <$> readData ["talks", "pt", "music.json"]

    cadenceB1htmlPt <- readDataUtf8 ["talks", "pt", "cadence_b1.html"]
    cadenceB1timePt <- jsonTiming <$> readData ["talks", "pt", "cadence_b1.json"]
    cadenceCAhtmlPt <- readDataUtf8 ["talks", "pt", "cadence_ca.html"]
    cadenceCAtimePt <- jsonTiming <$> readData ["talks", "pt", "cadence_ca.json"]
    cadenceL5htmlPt <- readDataUtf8 ["talks", "pt", "cadence_l5.html"]
    cadenceL5timePt <- jsonTiming <$> readData ["talks", "pt", "cadence_l5.json"]
    cadenceLOhtmlPt <- readDataUtf8 ["talks", "pt", "cadence_lo.html"]
    cadenceLOtimePt <- jsonTiming <$> readData ["talks", "pt", "cadence_lo.json"]

    textbitsB1htmlPt <- readDataUtf8 ["talks", "pt", "textbits_b1.html"]
    textbitsB1timePt <- jsonTiming <$> readData ["talks", "pt", "textbits_b1.json"]
    textbitsCAhtmlPt <- readDataUtf8 ["talks", "pt", "textbits_ca.html"]
    textbitsCAtimePt <- jsonTiming <$> readData ["talks", "pt", "textbits_ca.json"]
    textbitsL5htmlPt <- readDataUtf8 ["talks", "pt", "textbits_l5.html"]
    textbitsL5timePt <- jsonTiming <$> readData ["talks", "pt", "textbits_l5.json"]
    textbitsLOhtmlPt <- readDataUtf8 ["talks", "pt", "textbits_lo.html"]
    textbitsLOtimePt <- jsonTiming <$> readData ["talks", "pt", "textbits_lo.json"]

    textmoreB1htmlPt <- readDataUtf8 ["talks", "pt", "textmore_b1.html"]
    textmoreB1timePt <- jsonTiming <$> readData ["talks", "pt", "textmore_b1.json"]
    textmoreCAhtmlPt <- readDataUtf8 ["talks", "pt", "textmore_ca.html"]
    textmoreCAtimePt <- jsonTiming <$> readData ["talks", "pt", "textmore_ca.json"]
    textmoreL5htmlPt <- readDataUtf8 ["talks", "pt", "textmore_l5.html"]
    textmoreL5timePt <- jsonTiming <$> readData ["talks", "pt", "textmore_l5.json"]
    textmoreLOhtmlPt <- readDataUtf8 ["talks", "pt", "textmore_lo.html"]
    textmoreLOtimePt <- jsonTiming <$> readData ["talks", "pt", "textmore_lo.json"]

    -- The main text on the Credits page is treated the same way as the html
    -- for a "talk", without corresponding timings of course, but it comes
    -- from Hamlet templates to allow links to static logos if necessary
    let creditsUrlEn  = $(hamletFile "templates/expo/data/credits_en.hamlet")
        creditsHtmlEn = renderHtml $ creditsUrlEn urlRender
    let creditsUrlEs  = $(hamletFile "templates/expo/data/credits_es.hamlet")
        creditsHtmlEs = renderHtml $ creditsUrlEs urlRender
    let creditsUrlPt  = $(hamletFile "templates/expo/data/credits_pt.hamlet")
        creditsHtmlPt = renderHtml $ creditsUrlPt urlRender

    -- Pure JSON is used as the file format for small messages, but it starts
    -- with a comment which needs to be skipped before attempting to decode
    -- it.
    msgContents <- readData ["messages.json"]
    let messages = jsonData $ dropWhile (/= _braceleft) msgContents

    -- Julius templates are used for things which require URL interpolation.
    -- See the discussion below concerning the use of `error`
    let jsonObj = fromMaybe (error "Bad json in julius file" :: Value)
                  . decode'
                  . encodeUtf8
                  . renderJavascriptUrl urlRender
    let urls      = jsonObj $(juliusFile "templates/expo/data/urls.julius")
        locUrls   = jsonObj $(juliusFile "templates/expo/data/locUrls.julius")
        locHLs    = jsonObj $(juliusFile "templates/expo/data/locHLs.julius")
        videos    = jsonObj $(juliusFile "templates/expo/data/videos.julius")
        locVideos = jsonObj $(juliusFile "templates/expo/data/locVideos.julius")

    locActives <- jsonData <$> readData ["locActives.json"]

    feedback <- if standAlone then return Null
                else jsonData <$> readData ["feedback.json"]

    -- HTML, including data, to embed in the TryCEAP game
    miniceapHtml <- miniCEAP

    -- This julius template combines all the pieces declared above
    let all = $(juliusFile "templates/expo/data/all.julius")

    -- Put it in the <head> to make sure it is in scope early.
    let dataWidget = toWidgetHead all

    expoLayout dataWidget


readData :: [ FilePath ] -> Handler ByteString
readData x = liftIO $ readFile
                    $ joinPath
                    $ ["templates", "expo", "data"] ++ x

readDataUtf8 :: [ FilePath ] -> Handler Text
readDataUtf8 x = liftIO $ readFileUtf8
                        $ joinPath
                        $ ["templates", "expo", "data"] ++ x


-- The files are all statically defined, and are all read when this handler
-- is called (which it always will be if the exhibition is being accessed
-- at all).  Therefore the fatal error here will occur reliably if any of
-- the data files are in error, and so it is the best way of ensuring that
-- any problems are found during development, rather than later!
--
jsonData :: ByteString -> Value
jsonData = fromMaybe (error "Bad json file") . decode' . fromStrict


-- To be pedantic about valid JSON, the timings are wrapped in an object
-- with the one property "timings".  This redundant structure is stripped
-- out here.
jsonTiming :: ByteString -> Value
jsonTiming bs =
    let v = jsonData bs
    in case v of
      Object obj -> fromMaybe (object []) $ lookup "timings" obj
      _          -> error "Bad timings file"


-- This handler serves a request made from the client code, and doesn't
-- return anything useful: the important thing is the side effect of logging
-- the access.  The result is simply "OK", but the parameter appears in the
-- log in the request URL, and is used to distinguish different cases.
getTrackR :: Text -> Handler Text
getTrackR _ = do
    alreadyExpired   -- Make sure caching doesn't hide any accesses
    return "OK"
